<!-- course: COMP 4710 Senior Design, Spring 2024 -->
<!-- author: Cady Pridgeon -->
<!-- credits:
    https://observablehq.com/@d3/zoomable-sunburst?intent=fork -->

<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Zoomable Sunburst Chart with CSV Data</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<style>

</style>

<body>
    <div id="chart"></div>

    <script>
        d3.csv("./data/authors.csv").then(function (authorData) {
            d3.csv("./data/books.csv").then(function (bookData) {

                var data = {
                    key: "sunburst",
                    children:
                        [
                            {
                                key: "18th Century",
                                children: [],
                            },
                            {
                                key: "19th Century",
                                children: [],
                            },
                            {
                                key: "20th Century",
                                children: [],
                            }
                        ]
                }

                var authors = authorData.map(function (a) {
                    var author = {
                        key: a["Item Id"],
                        values: [],
                        children: [],
                    };
                    for (var prop in a) {
                        if (prop !== "Item Id") {
                            author.values.push({
                                [prop]: a[prop]
                            })
                        }
                        if (prop === "Dublin Core:Date Submitted") {
                            if (parseInt(a[prop]) < 1800) {
                                author.parent = "18th Century"
                                data.children[0].children.push(author)
                            }
                            else if (parseInt(a[prop]) >= 1800 && parseInt(a[prop]) < 1900) {
                                author.parent = "19th Century"
                                data.children[1].children.push(author)
                            }
                            else if (parseInt(a[prop]) >= 1900) {
                                author.parent = "20th Century"
                                data.children[2].children.push(author)
                            }
                            else {
                                author.parent = ""
                            }
                        }

                    }
                    bookData.forEach(function (b) {
                        author.values.forEach(function (v) {
                            if (b["Dublin Core:Conforms To"] === v["Dublin Core:Title"]) {
                                var book = {
                                    key: b["Item Id"],
                                    values: [],
                                };
                                for (var prop in b) {
                                    if (prop !== "Item Id") {
                                        book.values.push({
                                            [prop]: b[prop]
                                        })
                                    }
                                }
                                book.parent = b["Dublin Core:Conforms To"]
                                author.children.push(book);
                            }
                        })
                    });
                    return author;
                });

                const chart = d3.select('#chart')

                const width = 928;
                const height = width;
                const radius = width / 6;

                const color = d3.scaleOrdinal(d3.quantize(d3.interpolateRainbow, data.children.length + 1));

                const hierarchy = d3.hierarchy(data)
                    .sum(d => d.key)
                    .sort((a, b) => b.key - a.key);
                const root = d3.partition()
                    .size([2 * Math.PI, hierarchy.height + 1])
                    (hierarchy);
                root.each(d => d.current = d);


                const arc = d3.arc()
                    .startAngle(d => d.x0)
                    .endAngle(d => d.x1)
                    .padAngle(d => Math.min((d.x1 - d.x0) / 2, 0.005))
                    .padRadius(radius * 1.5)
                    .innerRadius(d => d.y0 * radius)
                    .outerRadius(d => Math.max(d.y0 * radius, d.y1 * radius - 1))

                const svg = chart.append("svg")
                    .attr("viewBox", [-width / 2, -height / 2, width, width])
                    .style("font", "10px sans-serif");

                const path = svg.append("g")
                    .selectAll("path")
                    .data(root.descendants().slice(1))
                    .join("path")
                    .attr("fill", d => { while (d.depth > 1) d = d.parent; return color(d.data.key); })
                    .attr("fill-opacity", d => arcVisible(d.current) ? (d.children ? 0.6 : 0.4) : 0)
                    .attr("pointer-events", d => arcVisible(d.current) ? "auto" : "none")

                    .attr("d", d => arc(d.current));




                path.filter(d => d.children)
                    .style("cursor", "pointer")
                    .on("click", clicked);

                const format = d3.format(",d");
                path.append("title")
                    .text(d => `${d.ancestors().map(d => d.data.key).reverse().join("/")}\n${format(d.key)}`);

                const label = svg.append("g")
                    .attr("pointer-events", "none")
                    .attr("text-anchor", "middle")
                    .style("user-select", "none")
                    .selectAll("text")
                    .data(root.descendants().slice(1))
                    .join("text")
                    .attr("dy", "0.35em")
                    .attr("fill-opacity", d => +labelVisible(d.current))
                    .attr("transform", d => labelTransform(d.current))
                    .text(d => {
                        const title = d.data.values ? d.data.values.map(obj => obj["Dublin Core:Title"]).join("\n") : d.data.key;
                        return `${title}`;
                    });

                const parent = svg.append("circle")
                    .datum(root)
                    .attr("r", radius)
                    .attr("fill", "none")
                    .attr("pointer-events", "all")
                    .on("click", clicked);

                function clicked(event, p) {
                    parent.datum(p.parent || root);

                    root.each(d => d.target = {
                        x0: Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                        x1: Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                        y0: Math.max(0, d.y0 - p.depth),
                        y1: Math.max(0, d.y1 - p.depth)
                    });

                    const t = svg.transition().duration(750);

                    path.transition(t)
                        .tween("data", d => {
                            const i = d3.interpolate(d.current, d.target);
                            return t => d.current = i(t);
                        })
                        .filter(function (d) {
                            return +this.getAttribute("fill-opacity") || arcVisible(d.target);
                        })
                        .attr("fill-opacity", d => arcVisible(d.target) ? (d.children ? 0.6 : 0.4) : 0)
                        .attr("pointer-events", d => arcVisible(d.target) ? "auto" : "none")

                        .attrTween("d", d => () => arc(d.current));

                    label.filter(function (d) {
                        return +this.getAttribute("fill-opacity") || labelVisible(d.target);
                    }).transition(t)
                        .attr("fill-opacity", d => +labelVisible(d.target))
                        .attrTween("transform", d => () => labelTransform(d.current));
                }

                function arcVisible(d) {
                    return d.y1 <= 3 && d.y0 >= 1 && d.x1 > d.x0;
                }

                function labelVisible(d) {
                    return d.y1 <= 3 && d.y0 >= 1 && (d.y1 - d.y0) * (d.x1 - d.x0) > 0.03;
                }

                function labelTransform(d) {
                    const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
                    const y = (d.y0 + d.y1) / 2 * radius;
                    return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
                }

                return svg.node();
            })
        })
    </script>
</body>

</html>