<!-- course: COMP 4710 Senior Design, Spring 2024 -->
<!-- author: Cady Pridgeon -->
<!-- credits:
    https://observablehq.com/@d3/zoomable-sunburst?intent=fork -->

<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Zoomable Sunburst Chart with CSV Data</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&display=swap"
        rel="stylesheet">
</head>

<style>
    body {
        font-family: "Crimson Text", serif;
    }
</style>

<body>
    <div id="chart"></div>

    <script>
        d3.csv("./data/authors.csv").then(function (authorData) {
            d3.csv("./data/books.csv").then(function (bookData) {

                var data = {
                    key: "sunburst",
                    children:
                        [
                            {
                                key: "18th Century",
                                children: [],
                            },
                            {
                                key: "19th Century",
                                children: [],
                            },
                            {
                                key: "20th Century",
                                children: [],
                            }
                        ]
                }

                var authors = authorData.map(function (a) {
                    var author = {
                        key: a["Item Id"],
                        values: [],
                        children: [],
                    };
                    for (var prop in a) {
                        if (prop !== "Item Id") {
                            author.values.push({
                                [prop]: a[prop]
                            })
                        }
                        if (prop === "Dublin Core:Date Submitted") {
                            if (parseInt(a[prop]) < 1800) {
                                author.parent = "18th Century"
                                data.children[0].children.push(author)
                            }
                            else if (parseInt(a[prop]) >= 1800 && parseInt(a[prop]) < 1900) {
                                author.parent = "19th Century"
                                data.children[1].children.push(author)
                            }
                            else if (parseInt(a[prop]) >= 1900) {
                                author.parent = "20th Century"
                                data.children[2].children.push(author)
                            }
                            else {
                                author.parent = ""
                            }
                        }

                    }
                    bookData.forEach(function (b) {
                        author.values.forEach(function (v) {
                            if (b["Dublin Core:Conforms To"] === v["Dublin Core:Title"]) {
                                var book = {
                                    key: b["Item Id"],
                                    values: [],
                                };
                                for (var prop in b) {
                                    if (prop !== "Item Id") {
                                        book.values.push({
                                            [prop]: b[prop]
                                        })
                                    }
                                }
                                book.parent = b["Dublin Core:Conforms To"]
                                author.children.push(book);
                            }
                        })
                    });
                    return author;
                });



                const chart = d3.select('#chart')

                const width = 928;
                const height = width;
                const radius = width / 6;

                const customColorScale = d3.scaleOrdinal()
                    .domain(["18th Century", "19th Century", "20th Century"])
                    .range(["#D97B78", "#e49444", "#8098BC"]);


                const hierarchy = d3.hierarchy(data)
                    .sum(d => d.key)
                    .sort((a, b) => b.key - a.key);
                const root = d3.partition()
                    .size([2 * Math.PI, hierarchy.height + 1])
                    (hierarchy);
                root.each(d => d.current = d);


                const arc = d3.arc()
                    .startAngle(d => d.x0)
                    .endAngle(d => d.x1)
                    .padAngle(d => Math.min((d.x1 - d.x0) / 2, 0.005))
                    .padRadius(radius * 1.5)
                    .innerRadius(d => d.y0 * radius)
                    .outerRadius(d => Math.max(d.y0 * radius, d.y1 * radius - 1))

                const svg = chart.append("svg")
                    .attr("viewBox", [-width / 2, -height / 2, width, width]);

                const path = svg.append("g")
                    .selectAll("path")
                    .data(root.descendants().slice(1))
                    .join("path")
                    .attr("fill", d => { while (d.depth > 1) d = d.parent; return customColorScale(d.data.key); })
                    .attr("fill-opacity", d => {
                        if (arcVisible(d.current)) {
                            if (d.children) {
                                return 1;
                            } else {
                                if (d.data.values && d.data.values[0]["Item URI"] !== null) {
                                    return 0.6;
                                } else {
                                    return 0.2;
                                }
                            }
                        } else {
                            return 0;
                        }
                    })
                    .attr("pointer-events", d => arcVisible(d.current) ? "auto" : "none")

                    .attr("d", d => arc(d.current));




                path.filter(d => d.children)
                    .style("cursor", "pointer")
                    .on("click", clicked);

                const format = d3.format(",d");
                path.append("title")
                    .text(d => `${d.ancestors().map(d => d.data.key).reverse().join("/")}\n${format(d.key)}`);

                const label = svg.append("g")
                    .attr("class", "text")
                    .attr("pointer-events", "none")
                    .attr("text-anchor", "middle")
                    .style("user-select", "none")
                    .selectAll("text")
                    .data(root.descendants().slice(1))
                    .join("text")
                    .attr("dy", "0.35em")
                    .attr("tabindex", 0)
                    .attr("font-size", "0.6em")
                    .attr("fill-opacity", d => +labelVisible(d.current))
                    .attr("transform", d => labelTransform(d.current))
                    .text(d => {
                        let title = d.data.values ? d.data.values.map(obj => obj["Dublin Core:Title"]).join("\n") : d.data.key;
                        if (title.trim().length > 20) {
                            title = title.trim().slice(0, 20) + "...";
                        }
                        return title;
                    });

                var currentIndex;
                const allPaths = path.nodes();
                const visibleArcs = path.filter(d => arcVisible(d.current)).nodes();
                const visibleArcIndices = visibleArcs.map(visiblePath => allPaths.indexOf(visiblePath));
                const visibleLabels = label.filter((d, i) => visibleArcIndices.includes(i)).nodes();


                chart.select("svg")
                    .selectAll("text")
                    .on("keydown", function (event, d) {
                        if (event.key === "Tab") {
                            console.log(visibleLabels, visibleArcs)
                            currentIndex = visibleLabels.indexOf(document.activeElement);

                            event.preventDefault();
                            if (event.shiftKey) {
                                const previousIndex = currentIndex === 0 ? visibleLabels.length - 1 : currentIndex - 1;
                                visibleLabels[previousIndex].focus();
                            } else {
                                const nextIndex = (currentIndex + 1) % visibleLabels.length;
                                visibleLabels[nextIndex].focus();
                            }
                            currentIndex = visibleLabels.indexOf(document.activeElement);
                            console.log(currentIndex)
                        }

                        if (event.key === "Enter") {
                            const pathElement = path.filter((d, i) => i === currentIndex);
                            if (!pathElement.empty()) {
                                pathElement.dispatch("click");
                            }
                        }
                    });



                document.addEventListener("keydown", function (event) {
                    if (event.key === "Backspace") {
                        const back = chart.select("circle");
                        back.dispatch("click");
                    }
                });

                const parent = svg.append("circle")
                    .datum(root)
                    .attr("r", radius)
                    .attr("fill", "none")
                    .attr("pointer-events", "all")
                    .on("click", clicked);




                function clicked(event, p) {


                    parent.datum(p.parent || root);

                    root.each(d => d.target = {
                        x0: Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                        x1: Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
                        y0: Math.max(0, d.y0 - p.depth),
                        y1: Math.max(0, d.y1 - p.depth)
                    });

                    const t = svg.transition().duration(750);

                    path.transition(t)
                        .tween("data", d => {
                            const i = d3.interpolate(d.current, d.target);
                            return t => d.current = i(t);
                        })
                        .filter(function (d) {
                            return +this.getAttribute("fill-opacity") || arcVisible(d.target);
                        })
                        .attr("fill-opacity", d => {
                            if (arcVisible(d.target)) {
                                if (d.children) {
                                    return 1;
                                } else {
                                    if (d.data.values && d.data.values[0]["Item URI"] !== null) {
                                        return 0.6;
                                    } else {
                                        return 0.2;
                                    }
                                }
                            } else {
                                return 0;
                            }
                        })
                        .attr("pointer-events", d => arcVisible(d.target) ? "auto" : "none")

                        .attrTween("d", d => () => arc(d.current));



                    label.filter(function (d) {
                        return +this.getAttribute("fill-opacity") || labelVisible(d.target);
                    }).transition(t)
                        .attr("fill-opacity", d => +labelVisible(d.target))
                        .attrTween("transform", d => () => labelTransform(d.current));



                }



                function arcVisible(d) {
                    return d.y1 <= 3 && d.y0 >= 1 && d.x1 > d.x0;
                }

                function labelVisible(d) {
                    return d.y1 <= 3 && d.y0 >= 1 && (d.y1 - d.y0) * (d.x1 - d.x0) > 0.03;
                }

                function labelTransform(d) {
                    const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
                    const y = (d.y0 + d.y1) / 2 * radius;
                    return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
                }

                return svg.node();
            })
        })
    </script>
</body>

</html>